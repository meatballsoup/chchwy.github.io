---
layout: post
published: false
title: 讀書心得--Effective C++ 3/e
categories: 讀書心得
tags: C++, 讀書心得
---

<a href="http://www.anobii.com/books/Effective_C_3e%E4%B8%AD%E6%96%87%E7%89%88/9789861543550/013a64b5e54ffd2279/" class="book-cover" title="More about Effective C++ 3/e中文版"><img alt="More about Effective C++ 3/e中文版" height="200" src="http://image.anobii.com/anobi/image_book.php?type=5&amp;item_id=013a64b5e54ffd2279&amp;time=1296528089" title="More about Effective C++ 3/e中文版" width="180" /></a>

Effective C++第一章第一句話就說清楚的這本書了：『學習語言的根本大法是一回事，學習如何以某種語言設計並實現高效程序則是另外一回事』，這本書就是把初學者在 C++ 裡容易碰到的問題，還有容易犯錯的地方，整理成55個條款列出來。

通常一位經驗豐富的程序員，必然也是一位踩過很多的語言地雷的程序員，他不只熟悉語言的光明面，他也必然懂得怎麼避開黑暗面。這本 Effective C++ 的優點就是挖出了很多 C++ 骯髒的部份，並攤在陽光下讓你看的一清二楚。C++這個語言很複雜，地雷也多，但是列出來的幾個地雷案例讓我嚇了一跳。

我舉個例子，在OO裡頭向上轉型很常見，但是你能猜到最後印出的結果嗎?

<pre class="prettyprint">
class B1 { public: int a; };
class B2 { public: int b; };
class D : public B1, public B2 { public: int c; };
int main() {
    D d;
    D* dp = &amp;d;
    B1* b1 = dp;
    B2* b2 = dp;
    printf("%p %p %p\n", dp, b1, b2);
}</pre>
結果是 dp、b1、b2 這三個指標位址不完全相同。指標轉型就會改變位址，這算什麼鬼？有趣的點是對dp、b1、b2 做==相等比較，結果竟然是正常的 (不知道編譯器做了什麼手腳，有掩耳盜鈴的感覺XD)。

但若不小心把指標轉型成long再做比較就會發生悲劇 (註一)。

書裡提了很多類似規則，你應該怎樣做，不該怎樣做，怎麼做會有危險等等，如果沒見過，我還真不知道那兒埋了一個語法地雷。

除了列舉地雷以外，這本書探討了一些語言設計上的議題，C++機制很多很雜，許多時候C++允許這樣寫，並不代表應該寫，最重要的是認識到語言設計背後的理念。

以下是一些抱怨，書裡一些條款，我覺得 C++ 這個語言為了維護「使用者不該為他沒有用到的功能付出效率的代價」的理念，發展出十足的細節。比方說一塊 new 分派的記憶體空間，必須不偏不倚剛好 delete 一次，忘了 detele 會 memory leaking，delete 多於一次又可能出問題。於是為了確保正確釋放資源，書中有十幾個條款探討各種狀況，各種怪招都有 -- 資源管理物件、auto_ptr、share_ptr，怪招中又有一些細節問題要小心，我心裡猛嘀咕，想要自己管記憶體，又怕管不好，幹嘛這麼折騰呢? 類似的細節還有成員函式inline、non-virtual、pure virtual、non-pure virtual 之間的差異，超乎我的想像。我明白這是C++的歷史包袱，不過把問題搞得如此複雜，真的值得嗎?

看了 C++ 語言充滿缺陷的黑暗面後，我其實有些沮喪，許多問題轉來轉去，最後只有無奈的說：沒有辦法適當地解決。看著這些缺點，再來看 Java 的改革的確相當切中時弊。不過時間點拉回到今天，眾多對Java的批評，我只能感嘆語言很難完美，C++提供高級抽象的同時又試圖保有最佳的執行效率，代價就是複雜；Java讓語言簡單，代價就是不夠靈活。還是要正確的認識語言的優點與缺點，然後適當地時機挑選適當地語言。

有些我個人覺得不錯的條款列在下面：

* 條款01：視C++為聯合國。C++是由四種不同風格組合而成的混血語言，這解答了我一個疑惑，怎麼每翻開一本新書，就發現原來我還不會寫C++。
* 條款03：深入探討const的各種用法跟意義，還有可能的問題，值得一看。
* 條款13、14、15、17：各種智慧型指標的用法，以及力有未逮之處。
* 條款22、23：對於封裝的權限有一番探討，一句話解釋封裝：「當其內容改變時可能造成的代碼破壞量」，太中肯了。
* 條款32~40：把C++的繼承從裡面翻到外面，每個細節都看過了。我認為最有價值的是解釋了繼承的各種用途跟意義，還有陷阱。

大部分關於template的條款時候未到，我還看不太懂。二年前我第一次翻 Effective C++，看不到十頁就棄械投降，今天卻看得津津有味，呵呵，果然還是要有經歷過才會有感受。註一：感謝ptt上tinlans與scwg的指點。